Задача 1
Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести эту операцию:

напишите список операций, которые вы будете производить для остановки запроса пользователя;
предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.


Решение:
Для решение проблем с долгими запросами мы можем использовать следующие команды:

Определение запроса:

Команда db.currentOp() для получения списка текущих операций в базе данных. Находим операцию, которую нужно прервать, и определяем её opid (идентификатор операции).
Прерывание операции:

Используем метод db.killOp(<opid>), где <opid> - это идентификатор операции, чтобы прервать выполнение запроса.

Логирование информации:
Записываем информацию о запросе, который был прерван, в журнал для последующего анализа. Это может быть полезно для выявления причин долгих запросов.
Чтобы решить проблему с долгими запросами в целом, вы можете принять следующие меры:

Индексация:
Проверяем, что используются необходимые индексы для поддержки запросов. Отсутствие индексов или неправильная индексация может привести к долгим операциям.

Профилирование запросов:
Включаем профилирование запросов с помощью db.setProfilingLevel(1, <threshold>). Анализируем результаты профилирования, чтобы выявить долгие операции.

Оптимизация запросов:
Перепроверяем код запросов и убеждаемся, что он оптимизирован. Могут потребоваться изменения структуры запросов или использование индексов.

Оптимизация конфигурации:
Проверяем конфигурацию MongoDB, такую как размер кеша (storage.wiredTiger.engineConfig.cacheSizeGB), и вносим необходимые изменения.

Масштабирование:
Рассмотрим возможность масштабирования системы, например, путем добавления реплик или шардинга, чтобы улучшить производительность.

После внесения изменений нужно следить за производительностью и анализировать журналы запросов для поиска дополнительных улучшений.


Задача 2
Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

сначала происходит рост отношения записанных значений к истекшим,
Redis блокирует операции записи.
Как вы думаете, в чём может быть проблема?


Решение:

Проблема может быть связана с увеличением количества реплик сервиса и ростом отношения записанных значений к истекшим, за которым следует блокировка операций записи в Redis. Это может быть вызвано проблемой с механизмом TTL (Time-To-Live) и процессом управления истекшими значениями в Redis.
В Redis TTL устанавливает время жизни для ключей, после истечения которого они удаляются. Если механизм TTL работает неэффективно или существует большое количество ключей с коротким TTL, это может вызвать проблемы с производительностью и блокировкой операций записи.

Возможные причины проблемы и подходы к решению:

Большое количество короткоживущих ключей:
Возможно, у нас существует большое количество ключей с коротким TTL, что приводит к частой очистке истекших ключей и, следовательно, блокировке операций записи. Надо попробовать оптимизировать использование TTL, увеличив время жизни ключей, если это возможно, или уменьшив количество короткоживущих ключей.

Интенсивное использование механизма TTL:
Надо проверить, не происходит ли интенсивное использование операций с TTL, что может вызвать блокировку. Мониторинг команд INFO и использование инструментов для анализа производительности Redis могут помочь выявить интенсивное использование.

Оптимизация процесса сбора мусора (Garbage Collection):
Redis выполняет процесс сбора мусора для удаления истекших ключей. В случае множества короткоживущих ключей, этот процесс может стать нагрузочным. Убедитесь, что Redis имеет достаточные ресурсы для выполнения операций сбора мусора.

Использование репликации:
При увеличении числа реплик, увеличивается и нагрузка на процесс репликации данных. Это также может повлиять на производительность и вызвать блокировку операций записи. Рассмотрите возможность оптимизации конфигурации репликации и увеличения ресурсов для обработки дополнительных реплик.

Важно также использовать инструменты мониторинга и журналирования Redis для более детального анализа производительности и выявления конкретных проблем


Задача 3
Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы пользователи начали жаловаться на ошибки вида:

InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения этой проблемы вы можете предложить?


Решение:

Возможные причины:

Таймаут соединения:
Если запрос выполняется слишком долго, может произойти превышение времени ожидания, и клиент потеряет соединение с сервером.

Проблемы с сетью:
Недоступность или нестабильное соединение сети может привести к потере связи с сервером MySQL в процессе выполнения запроса.
Проблемы с ресурсами:

Если сервер MySQL испытывает нехватку ресурсов (памяти, CPU и т. д.), это может вызвать потерю соединения в процессе выполнения запроса.
Локализация проблемы:

Логи MySQL:
Проверяем логи MySQL на наличие сообщений об ошибках или предупреждений, которые могли бы указать на проблемы соединения или выполнения запросов.

Мониторинг производительности:
Используем инструменты мониторинга производительности MySQL (например, MySQL Performance Schema) для выявления узких мест и проблем с ресурсами.

Проверка сетевых проблем:
Проверяем статус сетевого соединения между клиентом и сервером MySQL. Используем инструменты, такие как ping и traceroute, curl чтобы выявить возможные проблемы сети.

Пути решения проблемы:

Настройка таймаутов:
Увеличиваем значения таймаутов в настройках MySQL, таких как wait_timeout и interactive_timeout, чтобы предотвратить разрыв соединения из-за долгих запросов.

Оптимизация запросов:
Пересмотрите и оптимизируйте запросы для улучшения производительности. Используйте индексы, избегайте сложных запросов, которые могут привести к блокировкам.

Увеличение ресурсов сервера:
Если проблемы с ресурсами, увеличьте объем памяти, выделенной для MySQL, и улучшите производительность сервера.

Обслуживание сети:
Необходимо проверить сетевую инфраструктуру для обнаружения и устранения проблем сети.

Использование пула соединений:
Можно рассмотреть использование пула соединений для эффективного управления соединениями с базой данных и предотвращения их избыточного открытия и закрытия.

Обновление MySQL:
В некоторых случаях, проблемы сетевого стека или производительности могут быть решены обновлением версии MySQL до более новой, стабильной версии.
Использование комбинации этих методов может помочь выявить и устранить проблему потери соединения в нашей гис-системе.



Задача 4
Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объёмом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

postmaster invoked oom-killer

Как вы думаете, что происходит?

Как бы вы решили эту проблему?


Решение:

Сообщение "postmaster invoked oom-killer" указывает на то, что в системе произошло исчерпание оперативной памяти (Out Of Memory, OOM), и был вызван механизм oom-killer, который автоматически завершает процессы для освобождения памяти. В данном случае, это касается процесса PostgreSQL (postmaster).

Потенциальные причины:

Недостаточное выделение памяти:

Возможно, выделенной оперативной памяти для PostgreSQL недостаточно для эффективной работы с большим объемом данных.
Некорректная конфигурация параметров памяти:

Неверная конфигурация параметров памяти PostgreSQL может привести к тому, что процесс потребляет больше памяти, чем доступно на сервере.

Нагрузка от других приложений:
Другие приложения на сервере могут также использовать значительные ресурсы оперативной памяти, что может увеличить давление на память.

Пути решения проблемы:
Проверка конфигурации параметров памяти PostgreSQL:

Нужно проверить настройки параметров памяти в конфигурационном файле PostgreSQL (postgresql.conf). Убедитесь, что выделено достаточно памяти для shared_buffers, work_mem, maintenance_work_mem, и других настроек.

Мониторинг памяти:
Используем инструменты мониторинга (например, top, htop, pg_stat_monitor), чтобы следить за использованием памяти PostgreSQL и другими процессами на сервере.

Ограничение ресурсов:
Используем инструменты для ограничения ресурсов, такими как cgroups в Linux, чтобы предотвратить перерасход памяти PostgreSQL и других процессов.

Увеличение выделенной оперативной памяти:
Если сервер испытывает большую нагрузку и выделенной памяти недостаточно, рассмотрите возможность увеличения объема оперативной памяти в системе.
Разграничение ресурсов между приложениями:

Если на сервере работают и другие приложения, рассмотрите возможность разграничения ресурсов между ними для предотвращения конфликтов по памяти.

Мониторинг запросов:
Анализируем выполнение запросов в PostgreSQL. Некоторые запросы могут быть неоптимальными и приводить к резкому росту потребления памяти.

Обновление PostgreSQL:
Возможно есть необходимость обновления PostgreSQL до последней версии, так как новые версии могут включать улучшения в управлении памятью.
После проведения этих шагов можно получить более точное представление о том, что вызывает проблему и как ее решить.
